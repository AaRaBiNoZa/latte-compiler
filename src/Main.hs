-- File generated by the BNF Converter (bnfc 2.9.5).

-- | Program to test parser.

module Main where

import Prelude
  ( ($), (.)
  , Either(..)
  , Int, (>)
  , String, (++), concat, unlines
  , Show, show
  , IO, (>>), (>>=), mapM_, putStrLn
  , FilePath
  , getContents, readFile, (==)
  )
import System.Environment ( getArgs )
import System.Exit        ( exitFailure )
import System.IO          ( hPutStrLn, stderr)
import Control.Monad      ( when )

import Latte.Abs   ( Program )
import Latte.Lex   ( Token, mkPosToken )
import Latte.Par   ( pProgram, myLexer )
import Latte.Print ( Print, printTree )
import Latte.Skel  ()

import qualified Npos.Latte.Par as Npos
import qualified TypeChecker as T

import IRCompiler (saveTacToFile, genTac, assemble)
import Data.Either (fromRight)
import Liveness (runFlowAnalysis, saveAliveInfoToFile)
import Ssa (runSsaTransform)

type Err        = Either String
type ParseFun a = [Token] -> Err a
type Ir         = Int

runFile :: Ir -> FilePath -> IO ()
runFile ir f = putStrLn f >> readFile f >>= run ir f

run :: Ir -> FilePath -> String -> IO ()
run ir f s = do
  case pProgram ts of
    Left err -> do
      hPutStrLn stderr "ERROR\n"
      hPutStrLn stderr "\nParse              Failed...\n"
      hPutStrLn stderr err
      exitFailure
    Right tree -> do
      case T.runTypeCheck tree of
          Left err -> hPutStrLn stderr ("ERROR\n" ++ T.showErr err) >> exitFailure
          Right _ -> hPutStrLn stderr "OK"
      putStrLn "\nParse Successful!"
  case Npos.pProgram nTs of
    Right nposTree -> do
      let tac = genTac nposTree
      let aliveInfo = runFlowAnalysis tac
      let ssa = runSsaTransform tac aliveInfo
      when (ir == 1) (do
        saveTacToFile f ".tac" tac
        saveAliveInfoToFile f aliveInfo
        )
      saveTacToFile f ".ll" ssa
      assemble f
    _ -> putStrLn "??"
    where
      ts = myLexer s
      nTs = Npos.myLexer s

usage :: IO ()
usage = do
  putStrLn $ unlines
    [ "usage: Call with one of the following argument combinations:"
    , "  --help          Display this help message."
    , "  (no arguments)  Parse stdin."
    , "  (files)         Parse content of files silently."
    , "  -ir (files)     Generate intermediate files."
    ]

main :: IO ()
main = do
  args <- getArgs
  case args of
    ["--help"] -> usage
    []         -> getContents >>= run 1 "stdio"
    "-ir":fs   -> mapM_ (runFile 1) fs
    fs         -> mapM_ (runFile 0) fs

